<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>理解javascript的作用域 | 叁歌</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.1.5"><link rel="stylesheet" type="text/css" href="/css/dark.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','G-HEVC7VFM0G','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '3b74b15709da4bba44d03cc55664915f';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">理解javascript的作用域</h1><a id="logo" href="/.">叁歌</a><p class="description">To be the best of best.</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">理解javascript的作用域</h1><div class="post-meta">2021-01-13</div><div class="post-content"><p>老规矩，带着问题去看本章的文章，更加高效。下面思考以下问题：</p>
<ul>
<li>什么是作用域以及作用域链，如何在作用域内查找一个标识符？</li>
<li>为什么在还没执行到函数声明的语句，却可以提前调用函数？</li>
</ul>
<p>带着这些疑问，我们进入今天的正题</p>
<h3 id="本文的整体结构"><a href="#本文的整体结构" class="headerlink" title="本文的整体结构"></a>本文的整体结构</h3><p><img src="/images/scope-1.jpeg"></p>
<h3 id="1-标识符（绑定）、作用域、作用域链"><a href="#1-标识符（绑定）、作用域、作用域链" class="headerlink" title="1. 标识符（绑定）、作用域、作用域链"></a>1. 标识符（绑定）、作用域、作用域链</h3><p>我们首先来讨论下<strong>标识符</strong>这个概念。<br>在<a target="_blank" rel="noopener" href="https://book.douban.com/subject/10546125/">《Javascript 高级程序设计(第三版)》</a>的第 3.1.2 中，我们可以看到这条概念：</p>
<blockquote>
<p>所谓标识符，就是指变量、函数、属性的名字，或者函数的参数<br>标识符可以是按照下列格式规则组合起来的一个或多个字符：</p>
<ul>
<li>第一个字符必须是字母、下划线（_）或一个美元符号</li>
<li>其他字符可以是字母、下划线、美元符号或数字</li>
</ul>
</blockquote>
<p>所以标识符其实就是我们平时为自己写的函数、变量等所起的名字。</p>
<p>接下来我们聊下作用域与作用域链的概念。<br>在<a target="_blank" rel="noopener" href="https://book.douban.com/subject/26351021/">《你不知道的 Javascript（上卷）》</a>的第 1.2.1 章有提到作用域的概念以及职责：</p>
<blockquote>
<p>作用域，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限.</p>
</blockquote>
<p>所以我们可以理解为，作用域的设计，主要是为了管理标识符的创建、查询、访问权限等，本质上是<strong>一套依据名称查找变量的规则</strong><br>**<br>当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套，例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Global Scope</span></span><br><span class="line"><span class="keyword">var</span> g = <span class="string">&#x27;anning&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Scope A</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Scope B</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Scope C</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到上述代码里，C 可以访问到 A、B、GlobalScope 中的标识符绑定，B 可以访问到 A、GlobalScope 中的标识符绑定，A 可以访问到 GlobalScope 中的标识符绑定<br>在 ScopeC 中，有一个外部引用指向 ScopeB，同样的，ScopeB 同样有个外部引用指向 ScopeA，ScopeA 有个外部引用指向 GlobalScope：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">ScopeC.outer -&gt; ScopeB</span><br><span class="line">ScopeB.outer -&gt; ScopeA</span><br><span class="line">ScopeA.outer -&gt; GlobalScope</span><br></pre></td></tr></table></figure>
<p>这一个不断 outer 指向父级的关系，即维护了一条<strong>作用域链，</strong>我们知道作用域是为了记录变量的，而作用域链就保证了对当前环境有权访问的某些变量和函数的有序访问</p>
<h3 id="2-词法环境"><a href="#2-词法环境" class="headerlink" title="2. 词法环境"></a>2. 词法环境</h3><p>在继续深入介绍作用域相关的知识前，一定绕不开的就是「词法环境」的概念。词法环境英文为 <a target="_blank" rel="noopener" href="https://www.ecma-international.org/ecma-262/5.1/index.html#sec-10.2">Lexical Environment</a>，文档中对其的定义为：</p>
<blockquote>
<p>A <em>Lexical Environment</em> is a specification type used to define the association of <em>Identifiers</em> to specific variables and functions based upon the lexical nesting structure of ECMAScript code.</p>
</blockquote>
<p>可以理解为，词法环境主要做了两件事情：<br>a. 记录标识符、函数<br>b. 记录标识符和函数的嵌套关系</p>
<blockquote>
<p>A Lexical Environment consists of an <a target="_blank" rel="noopener" href="https://www.ecma-international.org/ecma-262/5.1/index.html#sec-10.2.1">Environment Record</a> and a possibly null reference to an <em>outer</em> Lexical Environment.</p>
</blockquote>
<p>词法环境由一个环境记录项和一个可能为空的外部词法环境的引用构成<br>与刚刚说的词法环境做的事情相对应，由以下两部分构成：<br>a. 环境记录项<br>b. 可能为空的外部词法环境</p>
<p>这里不会对环境记录项做展开的解释，可以理解为，环境记录项就是一个 map&lt;K, V&gt; 结构，以变量、函数的名字为 key，其值为 value 的集合，更深层的解释可以<a target="_blank" rel="noopener" href="https://www.notion.so/f2c18133e7894c858fceb4653752ff94#0f7fd43dcc004a4ea212fe399ac7833e">我的笔记中的这部分内容</a></p>
<p>我们主要来关注下「可能为空的外部词法环境」这里的内容。</p>
<blockquote>
<p>The outer environment reference is used to model the logical nesting of Lexical Environment values</p>
</blockquote>
<p>外部词法环境我们可以想象成一种层层嵌套的结构，每一层都有一个 outer 指向外层：<br><img src="/images/scope-2.svg" alt="词法环境组件.svg"></p>
<p>是不是看起来很熟悉，看起来就很像我们刚刚提到的作用域嵌套！</p>
<h3 id="3-执行环境"><a href="#3-执行环境" class="headerlink" title="3. 执行环境"></a>3. 执行环境</h3><p>执行环境使我们代码执行的过程中，推向执行栈的那个环境，持有者该环境内的标识符绑定和 this 绑定<br>作用域就可以理解为这个执行环境（大致理解）</p>
<h4 id="3-1-组成"><a href="#3-1-组成" class="headerlink" title="3.1 组成"></a>3.1 组成</h4><p>执行环境具体包含三部分：</p>
<p><img src="/images/scope-3.svg" alt="执行环境.svg"></p>
<p>这里词法环境和变量环境，其模型都是一个第 2 节提到的词法环境组件，所以其内部各自存储了一些标识符的绑定以及向外部词法环境的引用。</p>
<h4 id="3-2-标识符的解析"><a href="#3-2-标识符的解析" class="headerlink" title="3.2 标识符的解析"></a>3.2 标识符的解析</h4><p>在有了前置的知识之后，我们来聊下标识符的解析过程</p>
<p>标识符解析的过程其实就是我们在执行环境的所有标识符绑定中，获取名为 name 的那个绑定<br>简单来说就是调用词法环境组件中，一个名为 GetIdentifierReference 的方法，该方法可以理解形成如下伪代码：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【伪代码】获取某个标识符的引用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@params </span>lex &#123;Lexical Environment&#125; 词法环境</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@params </span>name &#123;String&#125; 标识符的名字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@params </span>strict &#123;Boolean&#125; 是否是严格模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Reference&#125;</span> </span>-- 返回的一定是一个名为 name 的引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetIdentifierReference</span>(<span class="params">lex, name, strict</span>): <span class="title">Reference</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> namedReference: Reference = <span class="literal">undefined</span></span><br><span class="line">  <span class="comment">// 没有环境的话，直接返回一个 undefined 的引用类型</span></span><br><span class="line">  <span class="keyword">if</span> (lex === <span class="literal">null</span>) <span class="keyword">return</span> namedReference</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> lex.HasBinding(name)</span><br><span class="line">    ? <span class="comment">// 当前词法环境里有绑定，则返回当前词法环境下的绑定</span></span><br><span class="line">      (namedReference = lex[name])</span><br><span class="line">    : <span class="comment">// 没有绑定，则递归在当前词法环境绑定的外部词法环境，继续寻找</span></span><br><span class="line">      GetIdentifierReference(lex.outer, name, strict)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如下面这个例子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> AIdentifier = <span class="string">&#x27;A Identifier&#x27;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 持有的外部引用指向 A 的词法环境</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">D</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// **持有 B 的词法环境的引用，B 又持有 A 的**</span></span><br><span class="line">      <span class="comment">// **所以 D 内可以访问到 D、B、A 内绑定的标识符**</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ****持有的外部引用指向 A 的词法环境</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设我们在 D 内查找名为 AIdentifier 的标识符:</p>
<ul>
<li>在 D 内查找 AIdentifier ⇒ GetIdentifierReference(D, ‘AIdentifier’, strict)</li>
<li>D 内没找到，进而去 B(D.outer)里找 ⇒ GetIdentifierReference(D.outer, ‘AIdentifier’, strict)</li>
<li>B 内也没找到，则去 A 里找 ⇒ GetIdentifierReference(D.outer.outer, ‘AIdentifier’, strict)</li>
<li>找到了，返回 AIdentifier 的引用</li>
</ul>
<p>这小节的内容，也就解释了开篇时提到的第一个问题：<br>什么是作用域以及作用域链，如何在作用域内查找一个标识符？</p>
<h3 id="4-标识符绑定初始化"><a href="#4-标识符绑定初始化" class="headerlink" title="4. 标识符绑定初始化"></a>4. 标识符绑定初始化</h3><p>每当我们执行某段代码或者进入到某个函数环境前，总会进行一些标识符的绑定，也就是很多博客中出现的「js 引擎会扫描整块代码，找出变量和函数去初始化」、「声明提升 hoisting」等知识.</p>
<h4 id="4-1-绑定的过程"><a href="#4-1-绑定的过程" class="headerlink" title="4.1 绑定的过程"></a>4.1 绑定的过程</h4><p>主要绑定的过程可以概述为：</p>
<ol>
<li>如果整块代码是函数代码，则先进行<strong>函数形参</strong>的绑定</li>
<li>扫描整块代码里的函数声明的绑定，依次绑定</li>
<li>如果之前没绑定过 arguments 标识符的话，则绑定 arguments 为参数列表（此处省略一大串逻辑）</li>
<li>绑定通过 var 声明的变量.</li>
</ol>
<p>我画了张图来说明整个过程：</p>
<p><img src="/images/scope-4.svg" alt="标识符初次绑定过程.svg"></p>
<p>此时我们解决开篇提到的第二个问题：<br>为什么在还没执行到函数声明的语句，却可以提前调用函数？</p>
<p>因为本身前置会进行很多的标识符绑定，函数的被绑定为其本身的函数值，其他标识符被绑定为 undefined. 所以我们在执行时，虽然还没到函数声明的语句，但是其实那个函数已经可以调用了~</p>
<h4 id="4-2-绑定的优先级-amp-同名标识符问题"><a href="#4-2-绑定的优先级-amp-同名标识符问题" class="headerlink" title="4.2 绑定的优先级 &amp; 同名标识符问题"></a>4.2 绑定的优先级 &amp; 同名标识符问题</h4><p>从图里我们可以看到，只有函数比较特殊：</p>
<p>对于函数声明，在每次检查了是否绑定过同名标识符之后，仍然会去更新绑定。<br>所以对于函数的声明，执行会有两条通路：</p>
<ul>
<li>hasDeclared: CreateBinding -&gt; SetBindingValue</li>
<li>hasNotDeclared: SetBindingValue</li>
</ul>
<p>对于其他的，诸如函数形参、var 语句声明的变量、arguments 这些，其实都只是做了初始化为 undefined 的操作，对于先后关系，其实并没有那么重要，重要的是后续执行过程中的时候的赋值。<br>比如比较特殊的 arguments 标识符，其实也可以进行修改：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被函数形参覆盖</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"><span class="built_in">arguments</span>, a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments =&gt; undefined</span></span><br><span class="line">test()</span><br><span class="line"><span class="comment">// arguments =&gt; 1</span></span><br><span class="line">test(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// arguments =&gt; 1</span></span><br><span class="line">test(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被内部函数标识符覆盖</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>())</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">arguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// log: 123</span></span><br><span class="line">test()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被内部 var 变量覆盖</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">arguments</span> = <span class="function">() =&gt;</span> <span class="number">345</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// log: 345</span></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<p>所以优先级可以整体被总结为：</p>
<p>「函数声明」 &gt; 「arguments、var 变量、函数形参」</p>
<h3 id="5-结语"><a href="#5-结语" class="headerlink" title="5. 结语"></a>5. 结语</h3><p>以上即为博主对作用域相关知识的解读，如有错误，欢迎指正~</p>
</div><div class="tags"><a href="/tags/%E5%89%8D%E7%AB%AF/"><i class="fa fa-tag"></i>前端</a><a href="/tags/ecmascript/"><i class="fa fa-tag"></i>ecmascript</a></div><div class="post-nav"><a class="pre" href="/2021/01/29/webpack/%E4%BB%8E-boundle-%E7%9C%8B%E6%95%B4%E4%B8%AA%E6%89%93%E5%8C%85%E5%90%8E%E7%9A%84%E6%96%87%E4%BB%B6/">webpack - 从 boundle 看整个打包后的文件</a><a class="next" href="/2021/01/12/algorithm/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/">快速排序</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 15px;">杂谈</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/HTTP-%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/" style="font-size: 15px;">HTTP 权威指南</a> <a href="/tags/%E3%80%8A%E4%B8%8D%E5%9C%A8%E4%BB%96%E6%96%B9%E3%80%8B/" style="font-size: 15px;">《不在他方》</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/You-Don-t-Know-Javascript/" style="font-size: 15px;">You Don't Know Javascript</a> <a href="/tags/%E3%80%8A%E5%A4%A9%E6%89%8D%E5%9C%A8%E5%B7%A6-%E7%96%AF%E5%AD%90%E5%9C%A8%E5%8F%B3%E3%80%8B/" style="font-size: 15px;">《天才在左 疯子在右》</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 15px;">数据结构</a> <a href="/tags/%E5%9F%BA%E6%9C%AC%E5%8A%9F/" style="font-size: 15px;">基本功</a> <a href="/tags/parser/" style="font-size: 15px;">parser</a> <a href="/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">源码学习</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/Acorn-js/" style="font-size: 15px;">Acorn.js</a> <a href="/tags/Babel/" style="font-size: 15px;">Babel</a> <a href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" style="font-size: 15px;">工程化</a> <a href="/tags/leetcode/" style="font-size: 15px;">leetcode</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/rfc/" style="font-size: 15px;">rfc</a> <a href="/tags/uri/" style="font-size: 15px;">uri</a> <a href="/tags/%E7%BC%96%E8%AF%91/" style="font-size: 15px;">编译</a> <a href="/tags/%E4%B8%A4%E5%91%A8%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">两周自制脚本语言</a> <a href="/tags/jquery/" style="font-size: 15px;">jquery</a> <a href="/tags/%E6%8A%80%E6%9C%AF%E9%92%BB%E7%A0%94/" style="font-size: 15px;">技术钻研</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 15px;">读书笔记</a> <a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">基础</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/" style="font-size: 15px;">前端进阶</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E5%9B%BD%E9%99%85%E5%8C%96/" style="font-size: 15px;">前端国际化</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">网络</a> <a href="/tags/typescript/" style="font-size: 15px;">typescript</a> <a href="/tags/Array-%E6%96%B9%E6%B3%95/" style="font-size: 15px;">Array 方法</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">前端基础</a> <a href="/tags/virtual-dom/" style="font-size: 15px;">virtual dom</a> <a href="/tags/%E9%98%9F%E5%88%97/" style="font-size: 15px;">队列</a> <a href="/tags/%E6%95%B0%E7%BB%84/" style="font-size: 15px;">数组</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="/tags/sort/" style="font-size: 15px;">sort</a> <a href="/tags/ecmascript/" style="font-size: 15px;">ecmascript</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">叁歌.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"></div></body></html>