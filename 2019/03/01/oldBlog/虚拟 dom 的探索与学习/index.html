<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>虚拟 dom 的探索与学习 | 叁歌</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.1.5"><link rel="stylesheet" type="text/css" href="/css/dark.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">虚拟 dom 的探索与学习</h1><a id="logo" href="/.">叁歌</a><p class="description">To be the best of best.</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">虚拟 dom 的探索与学习</h1><div class="post-meta">2019-03-01<span> | </span><span class="category"><a href="/categories/%E6%97%A7%E5%8D%9A%E5%AE%A2/"> 旧博客  </a></span></div><div class="post-content"><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文参考的虚拟 dom 库为 <a target="_blank" rel="noopener" href="https://github.com/Matt-Esch/virtual-dom">https://github.com/Matt-Esch/virtual-dom</a></p>
<p>本文可以告诉下列东西，篇幅较长：</p>
<ol>
<li>virtual dom 做了哪些事</li>
<li>virtual dom 需要提供哪些接口哪些方法</li>
<li>得到实现这些方法的大致思路</li>
<li>得到一份完整注释的参考库源码</li>
</ol>
<p>转载请保留出处</p>
<h2 id="从官方-demo-开始"><a href="#从官方-demo-开始" class="headerlink" title="从官方 demo 开始"></a>从官方 demo 开始</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1: Create a function that declares what the DOM should look like</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">count</span>)  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, &#123;</span><br><span class="line">        style: &#123;</span><br><span class="line">            textAlign: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">            lineHeight: (<span class="number">100</span> + count) + <span class="string">&#x27;px&#x27;</span>,</span><br><span class="line">            border: <span class="string">&#x27;1px solid red&#x27;</span>,</span><br><span class="line">            width: (<span class="number">100</span> + count) + <span class="string">&#x27;px&#x27;</span>,</span><br><span class="line">            height: (<span class="number">100</span> + count) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [<span class="built_in">String</span>(count)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2: Initialise the document</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;      <span class="comment">// We need some app data. Here we just store a count.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tree = render(count);               <span class="comment">// We need an initial tree</span></span><br><span class="line"><span class="keyword">var</span> rootNode = createElement(tree);     <span class="comment">// Create an initial root DOM node ...</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(rootNode);    <span class="comment">// ... and it should be in the document</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3: Wire up the update logic</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newTree = render(count);</span><br><span class="line">    <span class="keyword">var</span> patches = diff(tree, newTree);</span><br><span class="line">    rootNode = patch(rootNode, patches);</span><br><span class="line">    tree = newTree;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>我们可以看到，这个使用过程为：</p>
<ul>
<li>声明 <code>render</code> 函数，函数体内会依据 <code>count</code> 参数，调用 <code>h</code> 函数生成不同的虚拟 dom 对象</li>
<li>调用 <code>render</code> 函数，依据 <code>count</code> 的初始值，生成初次的虚拟 dom 对象</li>
<li>调用 <code>createElement</code> 函数，将虚拟 dom 对象生成真实 dom</li>
<li>真实 dom 插入 html 文档</li>
<li>设置定时器，定时器内部：<ul>
<li>每隔1s更新一次 <code>count</code> 值, 依据新的 <code>count</code> 值生成新的虚拟 dom 对象</li>
<li><code>diff</code> 新的虚拟 dom 对象与原有的虚拟 dom 对象</li>
<li>将 <code>diff</code> 的结果 <code>patch</code> 到真实 dom 中</li>
</ul>
</li>
</ul>
<p>试着考虑下整个过程，我们不难发现，整个虚拟 dom 概念，需要提供的就是：</p>
<ol>
<li>虚拟 dom 生成函数</li>
<li>虚拟 dom 向真实 dom 的转化函数</li>
<li>新旧虚拟 dom 片段的 diff 函数</li>
<li>将 diff 结果应用到真实 dom 上的 patch 函数</li>
</ol>
<p><img src="https://raw.githubusercontent.com/amnhh/blog-images/master/2019-03/virtual-dom-1.png"></p>
<h2 id="h-函数"><a href="#h-函数" class="headerlink" title="h 函数"></a>h 函数</h2><p>我们首先来看 <code>h</code> 函数, 这个函数作用为生成虚拟 dom 的 js 对象</p>
<p>先考虑下我们的 <code>html</code> 节点，比如一个 <code>&lt;p&gt;</code> 标签：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;anning&quot;</span> <span class="attr">id</span>=<span class="string">&quot;amnhh&quot;</span>&gt;</span>这是一个P标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们把它拆分来看：</p>
<p><img src="https://raw.githubusercontent.com/amnhh/blog-images/master/2019-03/virtual-dom-2.png"></p>
<p>可以得到虚拟 dom 的几个关键字：</p>
<ul>
<li>tagName =&gt; 标签名</li>
<li>properties =&gt; 属性集合</li>
<li>children =&gt; 子元素集合</li>
</ul>
<p>我们简单来看下参考库中的 <code>h</code> 函数的定义</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">tagName, properties, children</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> childNodes = [];</span><br><span class="line">    <span class="keyword">var</span> tag, props, key, namespace;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 兼容 h(tagName, children) 的调用方式</span></span><br><span class="line">    <span class="keyword">if</span> (!children &amp;&amp; isChildren(properties)) &#123;</span><br><span class="line">        children = properties;</span><br><span class="line">        props = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    props = props || properties || &#123;&#125;;</span><br><span class="line">    <span class="comment">// 解析 tagName</span></span><br><span class="line">    tag = parseTag(tagName, props);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// support keys</span></span><br><span class="line">    <span class="keyword">if</span> (props.hasOwnProperty(<span class="string">&#x27;key&#x27;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 给 key 赋值，并且将 props 对象中的 key 置空</span></span><br><span class="line">        <span class="comment">// 因为我们设置 key 的本意，并不是为 dom 元素设置一个常规属性 key</span></span><br><span class="line">        <span class="comment">// 而是为了给 dom 元素增加索引，所以 key 属性并不应该出现在 props 这个对象中</span></span><br><span class="line">        key = props.key;</span><br><span class="line">        props.key = <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// support namespace</span></span><br><span class="line">    <span class="keyword">if</span> (props.hasOwnProperty(<span class="string">&#x27;namespace&#x27;</span>)) &#123;</span><br><span class="line">        namespace = props.namespace;</span><br><span class="line">        props.namespace = <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要用来处理事件绑定</span></span><br><span class="line">    transformProperties(props);</span><br><span class="line">    <span class="comment">// 处理 children</span></span><br><span class="line">    <span class="keyword">if</span> (children !== <span class="literal">undefined</span> &amp;&amp; children !== <span class="literal">null</span>) &#123;</span><br><span class="line">        addChild(children, childNodes, tag, props);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一个 VNode 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> VNode(tag, props, childNodes, key, namespace);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，<code>h</code> 函数其实就只是对很多参数做了处理之后，返回一个以这些参数生成的 <code>VNode</code> 实例:</p>
<p><img src="https://raw.githubusercontent.com/amnhh/blog-images/master/2019-03/virtual-dom-3.png"></p>
<p>我们刚刚可以看到，<code>h</code> 函数最后返回的是 <code>VNode</code> 的实例，这里把 <code>VNode</code> 叫成是一个类可能更好一些。</p>
<p>这个类的定义具体细节就不展开说了，只说下它做的事情：</p>
<ol>
<li>缓存 <code>tagName</code>, <code>properties</code>, <code>children</code>, <code>key</code>, <code>namespace</code> 到实例下</li>
<li>统一将事件缓存到 <code>hooks</code> 属性下</li>
<li>计算后代所有 <code>children</code> 的个数，缓存到 <code>count</code> 属性下</li>
<li>一些其他的属性的缓存</li>
</ol>
<p>具体代码可以移步有完整注释的这里 :</p>
<p><a target="_blank" rel="noopener" href="https://github.com/amnhh/virtual-dom/blob/master/vnode/vnode.js#L12">https://github.com/amnhh/virtual-dom/blob/master/vnode/vnode.js#L12</a></p>
<h2 id="createElement-函数"><a href="#createElement-函数" class="headerlink" title="createElement 函数"></a>createElement 函数</h2><p>我们有了拥有着 <code>tagName</code>, <code>properties</code>, <code>children</code> 等属性的 js 对象后，需要将这些遵循 html 的规范，生成真实 DOM 结构</p>
<p>这个 <code>createElement</code> 函数就是用来将虚拟 dom 对象转化为真实 DOM 结构的函数</p>
<p>假设我们现有的是这样一个树对象：</p>
<p><img src="https://raw.githubusercontent.com/amnhh/blog-images/master/2019-03/virtual-dom-4.png"></p>
<p>我们先要考虑这个节点，是一个类似 <code>&lt;p&gt;</code> 的标签，还是只是一个文本节点</p>
<p>创建标签我们一般的手段为 <code>document.createElement</code>, 创建文本节点为 <code>document.createTextNode</code> 方法，根据不同的情况选用不同的方法</p>
<p>所以这里我们会执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>此时得到的元素为一个 <code>&lt;div&gt;&lt;/div&gt;</code></p>
<p>接下来需要将 <code>properties</code> 应用到这个 <code>div</code> 上，这里我们需要考虑到，我们在 <code>properties</code> 不光会存储类似 <code>id</code>, <code>class</code> 这样特殊的属性，这些属性可以直接以 <code>property</code> 的形式赋值，表现为 <code>node</code> 的 <code>attribute</code>，类似 <code>src</code>、<code>id</code>、<code>checked</code> 等</p>
<p>还有类似：<code>ev-click</code>(<code>ev-*</code> 为 <code>vdom</code> 参考库的事件前缀，可能为函数)、<code>style</code>(样式)、<code>attributes</code>(标签属性)这些可能为对象的形式</p>
<p>在代码中需要对这些进行兼容处理，如 <code>style</code> 会对 <code>node.style[stylePropName]</code> 进行赋值，<code>attributes</code> 会使用 <code>setAttribute</code>、<code>removeAttribute</code> 进行赋值等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyProperties</span>(<span class="params">node, props, previous</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// for in 遍历所有 vnode.properties</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> propName <span class="keyword">in</span> props) &#123;</span><br><span class="line">        <span class="keyword">var</span> propValue = props[propName]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (propValue === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="comment">// 不允许空...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isHook(propValue)) &#123;</span><br><span class="line">            <span class="comment">// 是事件 hook 的情况....</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 是对象的情况，此时会对 attribute 和 style 做单独处理</span></span><br><span class="line">            <span class="keyword">if</span> (isObject(propValue)) &#123;</span><br><span class="line">                patchObject(node, props, previous, propName, propValue);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则就是一个 property</span></span><br><span class="line">                <span class="comment">// 直接可以考虑为一个 node 对象的属性</span></span><br><span class="line">                node[propName] = propValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchObject</span>(<span class="params">node, props, previous, propName, propValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> previousValue = previous ? previous[propName] : <span class="literal">undefined</span></span><br><span class="line">    <span class="comment">// 是 attribute 则使用 setAttribute 和 removeAttribute </span></span><br><span class="line">    <span class="keyword">if</span> (propName === <span class="string">&quot;attributes&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> attrName <span class="keyword">in</span> propValue) &#123;</span><br><span class="line">            <span class="keyword">var</span> attrValue = propValue[attrName]</span><br><span class="line">            <span class="keyword">if</span> (attrValue === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                node.removeAttribute(attrName)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.setAttribute(attrName, attrValue)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// other code...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 style</span></span><br><span class="line">    <span class="keyword">var</span> replacer = propName === <span class="string">&quot;style&quot;</span> ? <span class="string">&quot;&quot;</span> : <span class="literal">undefined</span></span><br><span class="line">    <span class="comment">// 赋值为类似 node.style.color = &#x27;red&#x27; 的形式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> propValue) &#123;</span><br><span class="line">        <span class="keyword">var</span> value = propValue[k]</span><br><span class="line">        node[propName][k] = (value === <span class="literal">undefined</span>) ? replacer : value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理 <code>properties</code> 之后，紧接着会去处理 <code>children</code>, 显而易见通过递归创建 <code>child</code>, 然后使用 <code>node.appendChild</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> children = vnode.children</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成并插入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> childNode = createElement(children[i], opts)</span><br><span class="line">    <span class="keyword">if</span> (childNode) &#123;</span><br><span class="line">        node.appendChild(childNode)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后将整个生成处理好的 node 返回</span></span><br><span class="line"><span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>
<p>总结起来经历了这些步骤：</p>
<p><img src="https://raw.githubusercontent.com/amnhh/blog-images/master/2019-03/virtual-dom-5.png"></p>
<p>有完善注释的代码可以查阅</p>
<p> <a target="_blank" rel="noopener" href="https://github.com/amnhh/virtual-dom/blob/master/vdom/create-element.js#L18">https://github.com/amnhh/virtual-dom/blob/master/vdom/create-element.js#L18</a></p>
<h2 id="diff-函数"><a href="#diff-函数" class="headerlink" title="diff 函数"></a>diff 函数</h2><p><code>diff</code> 函数可以说是我们认知里虚拟 dom 最复杂的部分了，不要方，我们一层一层拨开来看</p>
<p>首先 <code>diff</code> 的主体是两个 <code>vnode</code> 节点，这里先称作新旧节点，简单来说有以下的情况：</p>
<p><img src="https://raw.githubusercontent.com/amnhh/blog-images/master/2019-03/virtual-dom-6.png"></p>
<p>其中可复用节点的 <code>diff</code> 过于复杂，可以后期新开一篇来讲，这里就不展开来说了</p>
<p>我们可以看到在每种情况的末尾，有不同的 <code>VPatch.VTEXT</code>, <code>VPatch.VNODE</code>, <code>VPatch.REMOVE</code> 等，其实这东西是一种标记，标记着新旧节点之间的差异</p>
<p>这里贴出有详尽注释的代码供大家查阅：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params">a, b, patch, index</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 a 和 b 两个引用都完全相同</span></span><br><span class="line">    <span class="comment">// 直接啥都不做</span></span><br><span class="line">    <span class="comment">// 对 patch 也啥都不做，直接终结</span></span><br><span class="line">    <span class="keyword">if</span> (a === b) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> apply = patch[index]</span><br><span class="line">    <span class="keyword">var</span> applyClear = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于我们入参是 tree 和 newTree</span></span><br><span class="line">    <span class="comment">// 都是 h 函数直接返回的 VNode</span></span><br><span class="line">    <span class="comment">// 所以直接跳过 isThunk 还有 b == null 的环节</span></span><br><span class="line">    <span class="keyword">if</span> (isThunk(a) || isThunk(b)) &#123;</span><br><span class="line">        thunks(a, b, patch, index)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If a is a widget we will add a remove patch for it</span></span><br><span class="line">        <span class="comment">// Otherwise any child widgets/hooks must be destroyed.</span></span><br><span class="line">        <span class="comment">// This prevents adding two remove patches for a widget.</span></span><br><span class="line">        <span class="keyword">if</span> (!isWidget(a)) &#123;</span><br><span class="line">            clearState(a, patch, index)</span><br><span class="line">            apply = patch[index]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        apply = appendPatch(apply, <span class="keyword">new</span> VPatch(VPatch.REMOVE, a, b))</span><br><span class="line">        <span class="comment">// 如果说 b 是一个 VNode</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isVNode(b)) &#123;</span><br><span class="line">        <span class="comment">// 直接进入到 a, b 都是 VNode 的环节</span></span><br><span class="line">        <span class="keyword">if</span> (isVNode(a)) &#123;</span><br><span class="line">            <span class="comment">// 如果是相同标签，相同 namespace，相同 key</span></span><br><span class="line">            <span class="comment">// 这特么也太严格了...</span></span><br><span class="line">            <span class="comment">// 感觉上应该是一种提升性能的体现</span></span><br><span class="line">            <span class="comment">// 直接调用 appendPatch 应该也是 ok 的</span></span><br><span class="line">            <span class="comment">// 但是如果说都满足的话，可以大量的节省时间</span></span><br><span class="line">            <span class="comment">// emmm... 这暂时只是个猜想</span></span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                a.tagName === b.tagName</span><br><span class="line">                &amp;&amp; a.namespace === b.namespace</span><br><span class="line">                &amp;&amp; a.key === b.key</span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="comment">// tagName，namespace，key都相同的话，说明可以认为是一个元素</span></span><br><span class="line">                <span class="comment">// 则我们不会去增减这个元素，只需要 diff props 看看是否需要更改就完事了</span></span><br><span class="line">                <span class="comment">// 对 properties 这个对象进行 diff</span></span><br><span class="line">                <span class="comment">// 以 test example1 为例的话</span></span><br><span class="line">                <span class="comment">// 这里就会返回： &#123; style : &#123; lineHeight : &#x27;101px&#x27;, width: &#x27;101px&#x27;, height: &#x27;101px&#x27; &#125; &#125;</span></span><br><span class="line">                <span class="keyword">var</span> propsPatch = diffProps(a.properties, b.properties)</span><br><span class="line">                <span class="keyword">if</span> (propsPatch) &#123;</span><br><span class="line">                    <span class="comment">// 这里我们只修改了 props</span></span><br><span class="line">                    <span class="comment">// 所以 apply 被赋值为了一个 VPatch 的实例</span></span><br><span class="line">                    <span class="comment">// 这个 VPatch实例中，</span></span><br><span class="line">                    <span class="comment">// type 参数传入的是 VPatch.PROPS, 也就是只是修改了属性 props</span></span><br><span class="line">                    <span class="comment">// vNode 参数传入的是 a, 也就是我们老的那个 DOM 对象，即要发生改变的那个 DOM</span></span><br><span class="line">                    <span class="comment">// patch 参数传入的是 propsDiff 的结果，这里就是 &#123; style : &#123; lineHeight : &#x27;101px&#x27;, width: &#x27;101px&#x27;, height: &#x27;101px&#x27; &#125; &#125;</span></span><br><span class="line">                    <span class="comment">// 此时 apply 其实就是我们 appendPatch 里说的，patch1</span></span><br><span class="line">                    <span class="comment">// 这时候 apply 就被赋值成了 &#123;type : 4, vNode : a, patch : &#123;style : &#123; lineHeight : &#x27;101px&#x27;, width: &#x27;101px&#x27;, height: &#x27;101px&#x27; &#125;&#125;&#125;</span></span><br><span class="line">                    apply = appendPatch(apply,</span><br><span class="line">                        <span class="keyword">new</span> VPatch(VPatch.PROPS, a, propsPatch))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 接下来就进入到 children 的 diff</span></span><br><span class="line">                <span class="comment">// 我们的两个 div 同时拥有着一个 VText 节点</span></span><br><span class="line">                apply = diffChildren(a, b, patch, apply, index)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                apply = appendPatch(apply, <span class="keyword">new</span> VPatch(VPatch.VNODE, a, b))</span><br><span class="line">                applyClear = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// b 是 vnode 而 a 不是 vnode 的话</span></span><br><span class="line">            <span class="comment">// 则向 patch 里 append VNODE 类型的 patch</span></span><br><span class="line">            <span class="comment">// VNODE 类型的 patch，最终反映到真实 dom 上是会直接调用 replaceNode 的</span></span><br><span class="line">            apply = appendPatch(apply, <span class="keyword">new</span> VPatch(VPatch.VNODE, a, b))</span><br><span class="line">            applyClear = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isVText(b)) &#123;</span><br><span class="line">        <span class="comment">// 如果说，b 是一个 text 节点而 a 不是一个 text 节点</span></span><br><span class="line">        <span class="keyword">if</span> (!isVText(a)) &#123;</span><br><span class="line">            <span class="comment">// 这里只是多于一个 applyClear 的样子...</span></span><br><span class="line">            apply = appendPatch(apply, <span class="keyword">new</span> VPatch(VPatch.VTEXT, a, b))</span><br><span class="line">            applyClear = <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.text !== b.text) &#123;</span><br><span class="line">            <span class="comment">// 如果两者都是 VTEXT</span></span><br><span class="line">            <span class="comment">// 也是需要一次 patch 的</span></span><br><span class="line">            apply = appendPatch(apply, <span class="keyword">new</span> VPatch(VPatch.VTEXT, a, b))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isWidget(b)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isWidget(a)) &#123;</span><br><span class="line">            applyClear = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        apply = appendPatch(apply, <span class="keyword">new</span> VPatch(VPatch.WIDGET, a, b))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (apply) &#123;</span><br><span class="line">        patch[index] = apply</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (applyClear) &#123;</span><br><span class="line">        clearState(a, patch, index)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p><code>patch</code> 用来将新旧节点的差异，更新到真实 dom 中</p>
<p>看到这里可能大家已经想到了各个 <code>VPatch.*</code> 的作用，其实 <code>VPatch.*</code> 是一种纽带，一边标示着新旧节点差异的类型，一边对应着不同的差异类型该执行的更新函数</p>
<p><code>VPatch</code> 类型各种各样，在这个参考库中列出了以下类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">VirtualPatch.NONE = <span class="number">0</span></span><br><span class="line">VirtualPatch.VTEXT = <span class="number">1</span></span><br><span class="line">VirtualPatch.VNODE = <span class="number">2</span></span><br><span class="line">VirtualPatch.WIDGET = <span class="number">3</span></span><br><span class="line">VirtualPatch.PROPS = <span class="number">4</span></span><br><span class="line">VirtualPatch.ORDER = <span class="number">5</span></span><br><span class="line">VirtualPatch.INSERT = <span class="number">6</span></span><br><span class="line">VirtualPatch.REMOVE = <span class="number">7</span></span><br><span class="line">VirtualPatch.THUNK = <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>每一种 <code>VPatch</code> 类型都对应着相应的处理函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyPatch</span>(<span class="params">vpatch, domNode, renderOptions</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> type = vpatch.type</span><br><span class="line">    <span class="keyword">var</span> vNode = vpatch.vNode</span><br><span class="line">    <span class="keyword">var</span> patch = vpatch.patch</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> VPatch.REMOVE:</span><br><span class="line">            <span class="keyword">return</span> removeNode(domNode, vNode)</span><br><span class="line">        <span class="keyword">case</span> VPatch.INSERT:</span><br><span class="line">            <span class="keyword">return</span> insertNode(domNode, patch, renderOptions)</span><br><span class="line">        <span class="keyword">case</span> VPatch.VTEXT:</span><br><span class="line">            <span class="keyword">return</span> stringPatch(domNode, vNode, patch, renderOptions)</span><br><span class="line">        <span class="keyword">case</span> VPatch.WIDGET:</span><br><span class="line">            <span class="keyword">return</span> widgetPatch(domNode, vNode, patch, renderOptions)</span><br><span class="line">        <span class="keyword">case</span> VPatch.VNODE:</span><br><span class="line">            <span class="keyword">return</span> vNodePatch(domNode, vNode, patch, renderOptions)</span><br><span class="line">        <span class="keyword">case</span> VPatch.ORDER:</span><br><span class="line">            reorderChildren(domNode, patch)</span><br><span class="line">            <span class="keyword">return</span> domNode</span><br><span class="line">        <span class="keyword">case</span> VPatch.PROPS:</span><br><span class="line">            applyProperties(domNode, patch, vNode.properties)</span><br><span class="line">            <span class="keyword">return</span> domNode</span><br><span class="line">        <span class="keyword">case</span> VPatch.THUNK:</span><br><span class="line">            <span class="keyword">return</span> replaceRoot(domNode,</span><br><span class="line">                renderOptions.patch(domNode, patch, renderOptions))</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> domNode</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会根据每种不同的 <code>VPatch</code> type 来调用不同的处理函数去处理旧节点，比如 <code>REMOVE</code> 就是移除节点，则会使用 <code>parent.removeChild</code>, <code>INSERT</code> 就是新增节点，使用 <code>parent.appendChild</code> ，<code>VTEXT</code> 和 <code>VNODE</code> 就是会执行文本、节点的替换，使用 <code>parent.replaceChild</code> 来替换，等等</p>
<p>总结来看，patch 就是一个将 diff 的结果转换到真实 dom 中的过程：</p>
<p><img src="https://raw.githubusercontent.com/amnhh/blog-images/master/2019-03/virtual-dom-7.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>是不是总体看下来，对虚拟 dom 有了个大致的了解？完整注释可以参考<a target="_blank" rel="noopener" href="https://github.com/amnhh/virtual-dom">这里</a></p>
<p>下面放出完整的思维导图，供大家理解：</p>
<p><img src="https://raw.githubusercontent.com/amnhh/blog-images/master/2019-03/virtual-dom-8.png"></p>
<p>谢谢阅读 ^ v ^</p>
</div><div class="tags"><a href="/tags/js/"><i class="fa fa-tag"></i>js</a><a href="/tags/%E6%8A%80%E6%9C%AF%E9%92%BB%E7%A0%94/"><i class="fa fa-tag"></i>技术钻研</a><a href="/tags/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"><i class="fa fa-tag"></i>前端进阶</a><a href="/tags/virtual-dom/"><i class="fa fa-tag"></i>virtual dom</a></div><div class="post-nav"><a class="pre" href="/2019/03/02/oldBlog/var-let-const/">这次，彻底弄懂var/let</a><a class="next" href="/2019/02/28/oldBlog/deferred%20%E8%AF%A6%E8%A7%A3/">jquery deferred 详解</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 15px;">杂谈</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/HTTP-%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/" style="font-size: 15px;">HTTP 权威指南</a> <a href="/tags/%E3%80%8A%E4%B8%8D%E5%9C%A8%E4%BB%96%E6%96%B9%E3%80%8B/" style="font-size: 15px;">《不在他方》</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/You-Don-t-Know-Javascript/" style="font-size: 15px;">You Don't Know Javascript</a> <a href="/tags/%E3%80%8A%E5%A4%A9%E6%89%8D%E5%9C%A8%E5%B7%A6-%E7%96%AF%E5%AD%90%E5%9C%A8%E5%8F%B3%E3%80%8B/" style="font-size: 15px;">《天才在左 疯子在右》</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 15px;">数据结构</a> <a href="/tags/%E5%9F%BA%E6%9C%AC%E5%8A%9F/" style="font-size: 15px;">基本功</a> <a href="/tags/parser/" style="font-size: 15px;">parser</a> <a href="/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">源码学习</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/Acorn-js/" style="font-size: 15px;">Acorn.js</a> <a href="/tags/Babel/" style="font-size: 15px;">Babel</a> <a href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" style="font-size: 15px;">工程化</a> <a href="/tags/leetcode/" style="font-size: 15px;">leetcode</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/rfc/" style="font-size: 15px;">rfc</a> <a href="/tags/uri/" style="font-size: 15px;">uri</a> <a href="/tags/%E7%BC%96%E8%AF%91/" style="font-size: 15px;">编译</a> <a href="/tags/%E4%B8%A4%E5%91%A8%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">两周自制脚本语言</a> <a href="/tags/jquery/" style="font-size: 15px;">jquery</a> <a href="/tags/%E6%8A%80%E6%9C%AF%E9%92%BB%E7%A0%94/" style="font-size: 15px;">技术钻研</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 15px;">读书笔记</a> <a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">基础</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/" style="font-size: 15px;">前端进阶</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E5%9B%BD%E9%99%85%E5%8C%96/" style="font-size: 15px;">前端国际化</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">网络</a> <a href="/tags/typescript/" style="font-size: 15px;">typescript</a> <a href="/tags/Array-%E6%96%B9%E6%B3%95/" style="font-size: 15px;">Array 方法</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">前端基础</a> <a href="/tags/virtual-dom/" style="font-size: 15px;">virtual dom</a> <a href="/tags/%E9%98%9F%E5%88%97/" style="font-size: 15px;">队列</a> <a href="/tags/%E6%95%B0%E7%BB%84/" style="font-size: 15px;">数组</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="/tags/sort/" style="font-size: 15px;">sort</a> <a href="/tags/ecmascript/" style="font-size: 15px;">ecmascript</a></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">叁歌.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"></div></body></html>