<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>webpack - Tapable -- 连接插件的桥梁 | 叁歌</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.1.5"><link rel="stylesheet" type="text/css" href="/css/dark.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script src="https://www.googletagmanager.com/gtag/js?id=G-HEVC7VFM0G" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());

gtag('config', 'G-HEVC7VFM0G');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '3b74b15709da4bba44d03cc55664915f';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">webpack - Tapable -- 连接插件的桥梁</h1><a id="logo" href="/.">叁歌</a><p class="description">To be the best of best.</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">webpack - Tapable -- 连接插件的桥梁</h1><div class="post-meta">2021-01-30</div><div class="post-content"><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>旨在通过学习 tapable 的源码，理解 tapable 的内部执行机制。</p>
<h2 id="2-tapable-简述"><a href="#2-tapable-简述" class="headerlink" title="2. tapable 简述"></a>2. tapable 简述</h2><p>官方对于 tapable 的概述，其实就是短小的一句话：</p>
<blockquote>
<p>Just a little module for plugins.</p>
</blockquote>
<p>我们知道 webpack 本身就可以理解为一系列的插件的聚合，而 tapable 就可以理解为是负责管理插件的一个模块，实现了一个类似于发布订阅的机制，更专注于自定义事件的绑定和触发<br>以 SyncHook 为例，他提供了：</p>
<ul>
<li>tap =&gt; 绑定事件</li>
<li>call =&gt; 触发事件</li>
</ul>
<p>我们在组织代码时，就可以只负责控制 hook 的初始化逻辑和触发逻辑，而开放事件的绑定能力，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> h = <span class="keyword">new</span> SyncHook([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定事件</span></span><br><span class="line">h.tap(<span class="string">&#x27;anning&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;~&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">h.tap(<span class="string">&#x27;again&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;~~&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">h.call()</span><br></pre></td></tr></table></figure>
<h2 id="3-提供的能力"><a href="#3-提供的能力" class="headerlink" title="3. 提供的能力"></a>3. 提供的能力</h2><p>tapable 通过定义一系列的 Hook 函数，为我们提供了「管理自身钩子的初始化和触发，并开放订阅」的能力。<br>在不同的维度又可以细分为多种钩子函数。</p>
<p>可以具体按以下为度划分：<br><img src="/images/tapable-1.jpeg"></p>
<p>简易的测试用例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每个钩子函数的测试 demo</span></span><br><span class="line"><span class="comment"> * 在 tapable 自己的 __tests__ 目录里自己建一个类似 hook.anning.js</span></span><br><span class="line"><span class="comment"> * 写进去用 ide 跑一下~</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  <span class="comment">// 同步钩子</span></span><br><span class="line">  SyncHook,</span><br><span class="line">  <span class="comment">// 同步熔断钩子</span></span><br><span class="line">  SyncBailHook,</span><br><span class="line">  <span class="comment">// 同步流水钩子</span></span><br><span class="line">  SyncWaterfallHook,</span><br><span class="line">  <span class="comment">// 同步循环钩子</span></span><br><span class="line">  SyncLoopHook,</span><br><span class="line">  <span class="comment">// 异步并发钩子</span></span><br><span class="line">  AsyncParallelHook,</span><br><span class="line">  <span class="comment">// 异步并发熔断钩子</span></span><br><span class="line">  AsyncParallelBailHook,</span><br><span class="line">  <span class="comment">// 异步串行钩子</span></span><br><span class="line">  AsyncSeriesHook,</span><br><span class="line">  <span class="comment">// 异步串行熔断钩子</span></span><br><span class="line">  AsyncSeriesBailHook,</span><br><span class="line">  <span class="comment">// 异步串行流水钩子</span></span><br><span class="line">  AsyncSeriesWaterfallHook,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;..&#x27;</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;Sync Hook test cases&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 依次执行</span></span><br><span class="line">  test(<span class="string">&#x27;SyncHook basic tap and call.&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> h = <span class="keyword">new</span> SyncHook([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">    h.tap(<span class="string">&#x27;anning&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;anning event triggered.&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    h.tap(<span class="string">&#x27;again&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;again event triggered.&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    h.call()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// anning event triggered</span></span><br><span class="line">    <span class="comment">// again event triggered.</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  test(<span class="string">&#x27;SyncBailHook basic tap and call&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 允许提前退出，只要在某个 tap 中返回了任何值，都会导致整体的事件触发提前退出</span></span><br><span class="line">    <span class="keyword">const</span> h = <span class="keyword">new</span> SyncBailHook([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    h.tap(<span class="string">&#x27;anning&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;anning event triggered and returns&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    h.tap(<span class="string">&#x27;again&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;again event triggered and returns&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    h.call()</span><br><span class="line">    <span class="comment">// anning event triggered and returns</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  test(<span class="string">&#x27;SyncWaterfallHook basic tap and call&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// SyncWaterfallHook 使用返回值，将一整个 taps 的触发过程串起来</span></span><br><span class="line">    <span class="comment">// 下一个 tap 的 cb 能接到上一个 tap 的返回值</span></span><br><span class="line">    <span class="keyword">const</span> h = <span class="keyword">new</span> SyncWaterfallHook([<span class="string">&#x27;water&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    h.tap(<span class="string">&#x27;anning&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;anning event triggered&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;【anning event returns】&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    h.tap(<span class="string">&#x27;again&#x27;</span>, <span class="function">(<span class="params">water</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`received water: <span class="subst">$&#123;water&#125;</span> from anning event.`</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;again event triggered and returns&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    h.call()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// anning event triggered</span></span><br><span class="line">    <span class="comment">// received water: 【anning event returns】 from anning event.</span></span><br><span class="line">    <span class="comment">// again event triggered and returns</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  test(<span class="string">&#x27;SyncLoopHook basic tap and call&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> h = <span class="keyword">new</span> SyncLoopHook([<span class="string">&#x27;l&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要有一个插件没有返回 undefined，所有的插件都会重头来过</span></span><br><span class="line">    <span class="comment">// 直到所有的插件全部都 return undefined.</span></span><br><span class="line">    h.tap(<span class="string">&#x27;anning&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;anning event triggered&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    h.tap(<span class="string">&#x27;again&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;again event triggered&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    h.tap(<span class="string">&#x27;bless&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;bless event triggered&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    h.call()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// anning event triggered</span></span><br><span class="line">    <span class="comment">// again event triggered</span></span><br><span class="line">    <span class="comment">// bless event triggered</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  test(<span class="string">&#x27;AsyncParallelHook&#x27;</span>, <span class="function">(<span class="params">done</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> h = <span class="keyword">new</span> AsyncParallelHook([<span class="string">&#x27;l&#x27;</span>])</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">&#x27;async parallel hook&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一种并发的方式去执行 taps</span></span><br><span class="line">    <span class="comment">// 顺序不能被保证~</span></span><br><span class="line">    <span class="comment">// async 和 promise 都执行完成后，再执行 callAsync 时的代码</span></span><br><span class="line">    h.tapAsync(<span class="string">&#x27;async test1&#x27;</span>, <span class="function">(<span class="params">l, cb</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;async test1&#x27;</span>)</span><br><span class="line">        cb()</span><br><span class="line">      &#125;, <span class="number">2000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    h.tapAsync(<span class="string">&#x27;async test2&#x27;</span>, <span class="function">(<span class="params">l, cb</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// return new Promise(resolve =&gt; &#123;</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;async test2&#x27;</span>)</span><br><span class="line">        cb()</span><br><span class="line">        <span class="comment">// resolve()</span></span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">      <span class="comment">// &#125;)</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    h.callAsync(<span class="string">&#x27;anning&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.timeEnd(<span class="string">&#x27;async parallel hook&#x27;</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;call&#x27;</span>)</span><br><span class="line">      done()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// async test2</span></span><br><span class="line">    <span class="comment">// async test1</span></span><br><span class="line">    <span class="comment">// async parallel hook: 2024ms</span></span><br><span class="line">    <span class="comment">// call</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  test(<span class="string">&#x27;AsyncParallelBailHook&#x27;</span>, <span class="function">(<span class="params">done</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> h = <span class="keyword">new</span> AsyncParallelBailHook([<span class="string">&#x27;arg&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果某个 async 的 tap 返回了非 undefined 的值</span></span><br><span class="line">    <span class="comment">// 则会直接转头去执行 callAsync 时的 callback</span></span><br><span class="line">    h.tapAsync(<span class="string">&#x27;async test1&#x27;</span>, <span class="function">(<span class="params">arg, cb</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;async test1&#x27;</span>)</span><br><span class="line">      cb(<span class="string">&#x27;anning&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    h.tapAsync(<span class="string">&#x27;async test2&#x27;</span>, <span class="function">(<span class="params">arg, cb</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;async test2&#x27;</span>)</span><br><span class="line">      cb()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    h.callAsync(<span class="string">&#x27;anning&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;call&#x27;</span>)</span><br><span class="line">      done()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// async test1</span></span><br><span class="line">    <span class="comment">// call</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  test(<span class="string">&#x27;AsyncSeriesHook&#x27;</span>, <span class="function">(<span class="params">done</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> h = <span class="keyword">new</span> AsyncSeriesHook([<span class="string">&#x27;arg&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 AsyncSeriesHook 时，虽然是异步，但是却在内部保证了顺序的执行</span></span><br><span class="line">    <span class="comment">// 先绑定则先执行</span></span><br><span class="line">    h.tapAsync(<span class="string">&#x27;async test1&#x27;</span>, <span class="function">(<span class="params">arg, cb</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;async test1&#x27;</span>)</span><br><span class="line">        cb()</span><br><span class="line">      &#125;, <span class="number">3000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    h.tapAsync(<span class="string">&#x27;async test2&#x27;</span>, <span class="function">(<span class="params">arg, cb</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;async test2&#x27;</span>)</span><br><span class="line">        cb()</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    h.callAsync(<span class="string">&#x27;anning&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;call&#x27;</span>)</span><br><span class="line">      done()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// async test1</span></span><br><span class="line">    <span class="comment">// async test2</span></span><br><span class="line">    <span class="comment">// call</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  test(<span class="string">&#x27;AsyncSeriesBailHook&#x27;</span>, <span class="function">(<span class="params">done</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> h = <span class="keyword">new</span> AsyncSeriesBailHook([<span class="string">&#x27;arg&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AsyncSeriesBailHook 还是将异步的钩子以绑定的顺序执行</span></span><br><span class="line">    <span class="comment">// 只是在每一层 cb 返回了非 undefined 的值的时候，就会转而去执行 callAsync 里的代码</span></span><br><span class="line">    h.tapAsync(<span class="string">&#x27;async test1&#x27;</span>, <span class="function">(<span class="params">arg, cb</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;async test1&#x27;</span>)</span><br><span class="line">        cb(<span class="number">5</span>)</span><br><span class="line">      &#125;, <span class="number">3000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    h.tapAsync(<span class="string">&#x27;async test2&#x27;</span>, <span class="function">(<span class="params">arg, cb</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;async test2&#x27;</span>)</span><br><span class="line">        cb()</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    h.callAsync(<span class="string">&#x27;anning&#x27;</span>, <span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;call&#x27;</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(arg, <span class="string">&#x27;returns, while execing callasync&#x27;</span>)</span><br><span class="line">      done()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// async test1</span></span><br><span class="line">    <span class="comment">// call</span></span><br><span class="line">    <span class="comment">// 5 returns, while execing callasync</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  test(<span class="string">&#x27;AsyncSeriesWaterfallHook&#x27;</span>, <span class="function">(<span class="params">done</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> h = <span class="keyword">new</span> AsyncSeriesWaterfallHook([<span class="string">&#x27;arg&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AsyncSeriesWaterfallHook 支持在每一层传递参数</span></span><br><span class="line">    <span class="comment">// 所以这个 5 被一层一层的被传递了下来</span></span><br><span class="line">    h.tapAsync(<span class="string">&#x27;async test1&#x27;</span>, <span class="function">(<span class="params">arg, cb</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;async test1&#x27;</span>)</span><br><span class="line">        cb(<span class="number">5</span>)</span><br><span class="line">      &#125;, <span class="number">3000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    h.tapAsync(<span class="string">&#x27;async test2&#x27;</span>, <span class="function">(<span class="params">arg, cb</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;async test2&#x27;</span>)</span><br><span class="line">        cb(arg)</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    h.callAsync(<span class="string">&#x27;anning&#x27;</span>, <span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;call&#x27;</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(arg, <span class="string">&#x27;returns, while execing callasync&#x27;</span>)</span><br><span class="line">      done()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// async test1</span></span><br><span class="line">    <span class="comment">// call</span></span><br><span class="line">    <span class="comment">// 5 returns, while execing callasync</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="4-具体源码（以-SyncHook-为例）"><a href="#4-具体源码（以-SyncHook-为例）" class="headerlink" title="4. 具体源码（以 SyncHook 为例）"></a>4. 具体源码（以 SyncHook 为例）</h2><p>测试用例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SyncHook = <span class="built_in">require</span>(<span class="string">&#x27;../SyncHook&#x27;</span>)</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;Sync Hook test cases&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  it(<span class="string">&#x27;basic tap and call.&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> h = <span class="keyword">new</span> SyncHook([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">    h.tap(<span class="string">&#x27;anning&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">debugger</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;~&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    h.tap(<span class="string">&#x27;again&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">debugger</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;~~&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    h.call()</span><br><span class="line">    <span class="keyword">debugger</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="4-1-h-tap-v-gt-xxx"><a href="#4-1-h-tap-v-gt-xxx" class="headerlink" title="4.1. h.tap(v =&gt; xxx)"></a>4.1. h.tap(v =&gt; xxx)</h3><p>首先 SyncHook 实例上的 tap 方法调用到 Hook 的 tap 方法中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hook</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">tap</span>(<span class="params">options, fn</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._tap(<span class="string">&#x27;sync&#x27;</span>, options, fn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，Hook 的 tap 又是私有方法 _tap 的代理，会写死一个 <code>sync</code> 的 type 一并传入到 _type 方法中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hook</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">_tap</span>(<span class="params">type, options, fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      options = &#123;</span><br><span class="line">        name: options,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> options !== <span class="string">&#x27;object&#x27;</span> || options === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Invalid tap options&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> options.name !== <span class="string">&#x27;string&#x27;</span> || options.name === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Missing name for tap&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> options.context !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">      deprecateContext()</span><br><span class="line">    &#125;</span><br><span class="line">    options = <span class="built_in">Object</span>.assign(&#123; type, fn &#125;, options)</span><br><span class="line">    <span class="comment">// TODO 暂时跳过 registe interceptors 的逻辑</span></span><br><span class="line">    options = <span class="built_in">this</span>._runRegisterInterceptors(options)</span><br><span class="line">    <span class="built_in">this</span>._insert(options)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_tap 方法对 options 做了部分的预处理、校验，而后直接再调用 _insert 方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hook</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">_insert</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._resetCompilation()</span><br><span class="line">    <span class="keyword">let</span> before</span><br><span class="line">    <span class="comment">// 处理 before =&gt; 使用 Set 进行去重</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> item.before === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      before = <span class="keyword">new</span> <span class="built_in">Set</span>([item.before])</span><br><span class="line">      <span class="comment">// 多个 before 也是先去重</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(item.before)) &#123;</span><br><span class="line">      before = <span class="keyword">new</span> <span class="built_in">Set</span>(item.before)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> stage = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> item.stage === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      stage = item.stage</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为属性的设置是 before, 意为选择排在哪个的前面 =&gt; 使用倒序插入</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="built_in">this</span>.taps.length</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      i--</span><br><span class="line">      <span class="keyword">const</span> x = <span class="built_in">this</span>.taps[i]</span><br><span class="line">      <span class="built_in">this</span>.taps[i + <span class="number">1</span>] = x</span><br><span class="line">      <span class="keyword">const</span> xStage = x.stage || <span class="number">0</span></span><br><span class="line">      <span class="keyword">if</span> (before) &#123;</span><br><span class="line">        <span class="comment">// 因为使用的是 Set 的 has 和 delete 方法</span></span><br><span class="line">        <span class="comment">// 所以如果说有传入两个值的话，插入到靠前的那个位置</span></span><br><span class="line">        <span class="keyword">if</span> (before.has(x.name)) &#123;</span><br><span class="line">          before.delete(x.name)</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果说 before 中存在一个整个 tap 都没有的值的话</span></span><br><span class="line">        <span class="comment">// 这里会无限跳过，然后 i 一直在减少</span></span><br><span class="line">        <span class="comment">// 最终插入到最前面</span></span><br><span class="line">        <span class="keyword">if</span> (before.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (xStage &gt; stage) &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      i++</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.taps[i] = item</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_insert 的前置操作，都是在寻找这个 tap 应该插入的位置。<br>寻找到之后，插入到 SyncHook 实例的 taps 属性中。</p>
<p>两次最基础的 tap 调用过后，SyncHook 实例上的 taps 拥有了如下的结构：<br><img src="/images/tapable-2.png" alt="image.png"></p>
<h3 id="4-2-h-call-v"><a href="#4-2-h-call-v" class="headerlink" title="4.2. h.call(v)"></a>4.2. h.call(v)</h3><p>首先调用到 h.call() 时，调到的是 Hook 的 call 方法，Hook 被实例化时，被赋值成了 CALL_DELEGATE 的索引：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CALL_DELEGATE = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.call = <span class="built_in">this</span>._createCall(<span class="string">&#x27;sync&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.call(...args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在首次调用 call 方法的时候，又会重新将 call 属性赋值为 Hook 的 _createCall 方法，而后再进行调用。<br>可以看到，call 方法在第一次和后续的访问时，有区分。</p>
<ul>
<li>第一次：<ul>
<li>call 被赋值为使用 _createCall -&gt; compile -&gt; SyncHookCodeFactory create 一整条链路创建的方法</li>
<li>调用被创建好的方法</li>
</ul>
</li>
<li>后续的访问：直接使用创建好的方法</li>
</ul>
<h4 id="4-2-1-this-call-的创建过程"><a href="#4-2-1-this-call-的创建过程" class="headerlink" title="4.2.1 this._call 的创建过程"></a>4.2.1 this._call 的创建过程</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hook</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">_createCall</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.compile(&#123;</span><br><span class="line">      taps: <span class="built_in">this</span>.taps,</span><br><span class="line">      interceptors: <span class="built_in">this</span>.interceptors,</span><br><span class="line">      args: <span class="built_in">this</span>._args,</span><br><span class="line">      type: type,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 compile 实例方法，在 SyncHook 中被重写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> COMPILE = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  factory.setup(<span class="built_in">this</span>, options)</span><br><span class="line">  <span class="keyword">return</span> factory.create(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SyncHook</span>(<span class="params">args = [], name = <span class="literal">undefined</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = <span class="keyword">new</span> Hook(args, name)</span><br><span class="line">  hook.constructor = SyncHook</span><br><span class="line">  hook.tapAsync = TAP_ASYNC</span><br><span class="line">  hook.tapPromise = TAP_PROMISE</span><br><span class="line">  <span class="comment">// there</span></span><br><span class="line">  hook.compile = COMPILE</span><br><span class="line">  <span class="keyword">return</span> hook</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 factory, 是 SyncHookCodeFactory 的实例.<br>首先调用到了 factory.setup 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HookCodeFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">instance, options</span>)</span> &#123;</span><br><span class="line">    instance._x = options.taps.map(<span class="function">(<span class="params">t</span>) =&gt;</span> t.fn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到整个安装过程，就只是将 hook 实例的 _x 属性使用 taps 集合的每一项的回调函数填充</p>
<p>之后使用 options 调用 factory.create 方法，该方法中，我们只聚焦 SyncHook 的调用路径下，即 options.type 为 ‘sync’ 的情况，其他的做简易的省略：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">create</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.init(options);</span><br><span class="line">		<span class="keyword">let</span> fn;</span><br><span class="line">		<span class="keyword">switch</span> (<span class="built_in">this</span>.options.type) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&quot;sync&quot;</span>:</span><br><span class="line">				fn = <span class="keyword">new</span> <span class="built_in">Function</span>(</span><br><span class="line">					<span class="built_in">this</span>.args(),</span><br><span class="line">					<span class="string">&#x27;&quot;use strict&quot;;\n&#x27;</span> +</span><br><span class="line">						<span class="built_in">this</span>.header() +</span><br><span class="line">						<span class="built_in">this</span>.contentWithInterceptors(&#123;</span><br><span class="line">							onError: <span class="function"><span class="params">err</span> =&gt;</span> <span class="string">`throw <span class="subst">$&#123;err&#125;</span>;\n`</span>,</span><br><span class="line">							onResult: <span class="function"><span class="params">result</span> =&gt;</span> <span class="string">`return <span class="subst">$&#123;result&#125;</span>;\n`</span>,</span><br><span class="line">							resultReturns: <span class="literal">true</span>,</span><br><span class="line">							onDone: <span class="function">() =&gt;</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">							rethrowIfPossible: <span class="literal">true</span></span><br><span class="line">						&#125;)</span><br><span class="line">				);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&quot;async&quot;</span>:</span><br><span class="line">				...</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&quot;promise&quot;</span>:</span><br><span class="line">				...</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">this</span>.deinit();</span><br><span class="line">		<span class="keyword">return</span> fn;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>首先调用 SyncHookCodeFactory -&gt; HookCodeFactory 的 init 方法，执行 HookCodeFactory 实例的配置改动：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HookCodeFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">init</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.options = options</span><br><span class="line">    <span class="built_in">this</span>._args = options.args.slice()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后执行的是整体函数的拼装，通过 new Function 的形式进行拼装：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn = <span class="keyword">new</span> <span class="built_in">Function</span>(args, body)</span><br></pre></td></tr></table></figure>
<p>在我们的例子中，在声明 hook 的时候并没有形参声明，所以跳过 this.args() 的步骤，<br>先是一些头部的字符拼装，产出的函数体字符串为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">var</span> _context</span><br><span class="line"><span class="keyword">var</span> _x = <span class="built_in">this</span>._x</span><br></pre></td></tr></table></figure>
<p>而后进入到 contentWithInterceptor 中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HookCodeFactory -&gt; create 的调用语句</span></span><br><span class="line"><span class="built_in">this</span>.contentWithInterceptors(&#123;</span><br><span class="line">  onError: <span class="function"><span class="params">err</span> =&gt;</span> <span class="string">`throw <span class="subst">$&#123;err&#125;</span>;\n`</span>,</span><br><span class="line">  onResult: <span class="function"><span class="params">result</span> =&gt;</span> <span class="string">`return <span class="subst">$&#123;result&#125;</span>;\n`</span>,</span><br><span class="line">  resultReturns: <span class="literal">true</span>,</span><br><span class="line">  onDone: <span class="function">() =&gt;</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">  rethrowIfPossible: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">contentWithInterceptors</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.options.interceptors.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  	...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.content(options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在我们的 demo 中，调用的是 factory 实例的 content 方法，这个方法本身不定义在 HookCodeFactory 中，而是在 SyncHookCodeFactory 时新增的方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncHookCodeFactory</span> <span class="keyword">extends</span> <span class="title">HookCodeFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">content</span>(<span class="params">&#123; onError, onDone, rethrowIfPossible &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.callTapsSeries(&#123;</span><br><span class="line">      onError: <span class="function">(<span class="params">i, err</span>) =&gt;</span> onError(err),</span><br><span class="line">      onDone,</span><br><span class="line">      rethrowIfPossible,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部直接调用的是 HookCodeFactory 中的 callTapsSeries 方法，在 callTapsSeries 中又使用 callTap 方法进行函数体的拼装：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">callTap</span>(<span class="params">tapIndex, &#123; onError, onResult, onDone, rethrowIfPossible &#125;</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">let</span> code = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">let</span> hasTapCached = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.options.interceptors.length; i++) &#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">		code += <span class="string">`var _fn<span class="subst">$&#123;tapIndex&#125;</span> = <span class="subst">$&#123;<span class="built_in">this</span>.getTapFn(tapIndex)&#125;</span>;\n`</span>;</span><br><span class="line">		<span class="keyword">const</span> tap = <span class="built_in">this</span>.options.taps[tapIndex];</span><br><span class="line">		<span class="keyword">switch</span> (tap.type) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&quot;sync&quot;</span>:</span><br><span class="line">				<span class="keyword">if</span> (!rethrowIfPossible) &#123;</span><br><span class="line">					code += <span class="string">`var _hasError<span class="subst">$&#123;tapIndex&#125;</span> = false;\n`</span>;</span><br><span class="line">					code += <span class="string">&quot;try &#123;\n&quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (onResult) &#123;</span><br><span class="line">					code += <span class="string">`var _result<span class="subst">$&#123;tapIndex&#125;</span> = _fn<span class="subst">$&#123;tapIndex&#125;</span>(<span class="subst">$&#123;<span class="built_in">this</span>.args(&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">						before: tap.context ? <span class="string">&quot;_context&quot;</span> : <span class="literal">undefined</span></span></span></span><br><span class="line"><span class="string"><span class="subst">					&#125;)&#125;</span>);\n`</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					code += <span class="string">`_fn<span class="subst">$&#123;tapIndex&#125;</span>(<span class="subst">$&#123;<span class="built_in">this</span>.args(&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">						before: tap.context ? <span class="string">&quot;_context&quot;</span> : <span class="literal">undefined</span></span></span></span><br><span class="line"><span class="string"><span class="subst">					&#125;)&#125;</span>);\n`</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (!rethrowIfPossible) &#123;</span><br><span class="line">					code += <span class="string">&quot;&#125; catch(_err) &#123;\n&quot;</span>;</span><br><span class="line">					code += <span class="string">`_hasError<span class="subst">$&#123;tapIndex&#125;</span> = true;\n`</span>;</span><br><span class="line">					code += onError(<span class="string">&quot;_err&quot;</span>);</span><br><span class="line">					code += <span class="string">&quot;&#125;\n&quot;</span>;</span><br><span class="line">					code += <span class="string">`if(!_hasError<span class="subst">$&#123;tapIndex&#125;</span>) &#123;\n`</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (onResult) &#123;</span><br><span class="line">					code += onResult(<span class="string">`_result<span class="subst">$&#123;tapIndex&#125;</span>`</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (onDone) &#123;</span><br><span class="line">					code += onDone();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (!rethrowIfPossible) &#123;</span><br><span class="line">					code += <span class="string">&quot;&#125;\n&quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&quot;async&quot;</span>:</span><br><span class="line">				...</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&quot;promise&quot;</span>:</span><br><span class="line">				...</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> code;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>经过这个方法，产出类似如下的字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _fn1 = _x[<span class="number">1</span>]</span><br><span class="line">_fn1(a, b, c)</span><br></pre></td></tr></table></figure>
<p>从后向前，每次调用 callTap 时，传入 () =&gt; beforeResultFnStr, 在这次新增的代码末尾拼装上上次的结果。<br>所以在调用完成后，整体的函数字符串长这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _fn0 = _x[<span class="number">0</span>]</span><br><span class="line">_fn0(a, b, c)</span><br><span class="line"><span class="keyword">var</span> _fn1 = _x[<span class="number">1</span>]</span><br><span class="line">_fn1(a, b, c)</span><br></pre></td></tr></table></figure>
<p>可以再结合上之前的头部，拼合上形参，产出的函数就是这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">a,b,c</span>) </span>&#123;</span><br><span class="line"><span class="meta">	&quot;use strict&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> _context;</span><br><span class="line">  <span class="keyword">var</span> _x = <span class="built_in">this</span>._x;</span><br><span class="line">  <span class="keyword">var</span> _fn0 = _x[<span class="number">0</span>];</span><br><span class="line">  _fn0(a, b, c);</span><br><span class="line">  <span class="keyword">var</span> _fn1 = _x[<span class="number">1</span>];</span><br><span class="line">  _fn1(a, b, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后直接返回这个函数的引用，供后续的调用。<br>厉害了…</p>
<h4 id="4-2-2-this-call-的调用"><a href="#4-2-2-this-call-的调用" class="headerlink" title="4.2.2 this.call 的调用"></a>4.2.2 this.call 的调用</h4><p>在 this._call 里存储了上述的匿名函数之后，而后就是简单的用参数去执行整个函数。</p>
<h3 id="4-3-值得注意的地方"><a href="#4-3-值得注意的地方" class="headerlink" title="4.3. 值得注意的地方"></a>4.3. 值得注意的地方</h3><p>在我们例子中，有如下的一个中间态：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">a,b,c</span>) </span>&#123;</span><br><span class="line"><span class="meta">	&quot;use strict&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> _context;</span><br><span class="line">  <span class="keyword">var</span> _x = <span class="built_in">this</span>._x;</span><br><span class="line">  <span class="keyword">var</span> _fn0 = _x[<span class="number">0</span>];</span><br><span class="line">  _fn0(a, b, c);</span><br><span class="line">  <span class="keyword">var</span> _fn1 = _x[<span class="number">1</span>];</span><br><span class="line">  _fn1(a, b, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个中间态的生成过程尤为关键，使用整个 taps 栈结构，拼装整个函数的 body 部分。</p>
<h2 id="5-结束"><a href="#5-结束" class="headerlink" title="5. 结束~"></a>5. 结束~</h2></div><div class="tags"><a href="/tags/javascript/"><i class="fa fa-tag"></i>javascript</a><a href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"><i class="fa fa-tag"></i>工程化</a><a href="/tags/webpack/"><i class="fa fa-tag"></i>webpack</a></div><div class="post-nav"><a class="pre" href="/2021/01/31/webpack/Complier-webpack-config-%E6%97%B6%E5%BE%97%E5%88%B0%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/">webpack - Complier -- webpack(config) 时得到的是什么？</a><a class="next" href="/2021/01/29/webpack/%E4%BB%8E-boundle-%E7%9C%8B%E6%95%B4%E4%B8%AA%E6%89%93%E5%8C%85%E5%90%8E%E7%9A%84%E6%96%87%E4%BB%B6/">webpack - 从 boundle 看整个打包后的文件</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 15px;">杂谈</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/HTTP-%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/" style="font-size: 15px;">HTTP 权威指南</a> <a href="/tags/%E3%80%8A%E4%B8%8D%E5%9C%A8%E4%BB%96%E6%96%B9%E3%80%8B/" style="font-size: 15px;">《不在他方》</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/You-Don-t-Know-Javascript/" style="font-size: 15px;">You Don't Know Javascript</a> <a href="/tags/%E3%80%8A%E5%A4%A9%E6%89%8D%E5%9C%A8%E5%B7%A6-%E7%96%AF%E5%AD%90%E5%9C%A8%E5%8F%B3%E3%80%8B/" style="font-size: 15px;">《天才在左 疯子在右》</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 15px;">数据结构</a> <a href="/tags/%E5%9F%BA%E6%9C%AC%E5%8A%9F/" style="font-size: 15px;">基本功</a> <a href="/tags/parser/" style="font-size: 15px;">parser</a> <a href="/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">源码学习</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/Acorn-js/" style="font-size: 15px;">Acorn.js</a> <a href="/tags/Babel/" style="font-size: 15px;">Babel</a> <a href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" style="font-size: 15px;">工程化</a> <a href="/tags/leetcode/" style="font-size: 15px;">leetcode</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/rfc/" style="font-size: 15px;">rfc</a> <a href="/tags/uri/" style="font-size: 15px;">uri</a> <a href="/tags/%E7%BC%96%E8%AF%91/" style="font-size: 15px;">编译</a> <a href="/tags/%E4%B8%A4%E5%91%A8%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">两周自制脚本语言</a> <a href="/tags/jquery/" style="font-size: 15px;">jquery</a> <a href="/tags/%E6%8A%80%E6%9C%AF%E9%92%BB%E7%A0%94/" style="font-size: 15px;">技术钻研</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 15px;">读书笔记</a> <a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">基础</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/" style="font-size: 15px;">前端进阶</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E5%9B%BD%E9%99%85%E5%8C%96/" style="font-size: 15px;">前端国际化</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">网络</a> <a href="/tags/typescript/" style="font-size: 15px;">typescript</a> <a href="/tags/Array-%E6%96%B9%E6%B3%95/" style="font-size: 15px;">Array 方法</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">前端基础</a> <a href="/tags/virtual-dom/" style="font-size: 15px;">virtual dom</a> <a href="/tags/%E9%98%9F%E5%88%97/" style="font-size: 15px;">队列</a> <a href="/tags/%E6%95%B0%E7%BB%84/" style="font-size: 15px;">数组</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="/tags/sort/" style="font-size: 15px;">sort</a> <a href="/tags/ecmascript/" style="font-size: 15px;">ecmascript</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">叁歌.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"></div></body></html>