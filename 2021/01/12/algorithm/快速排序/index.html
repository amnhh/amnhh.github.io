<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>快速排序 | 叁歌</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.1.5"><link rel="stylesheet" type="text/css" href="/css/dark.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">快速排序</h1><a id="logo" href="/.">叁歌</a><p class="description">To be the best of best.</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">快速排序</h1><div class="post-meta">2021-01-12</div><div class="post-content"><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>快速排序属于比较型排序算法，是一种分治思想应用的算法（有关分治思想的理解和学习，可以参考这篇：<a target="_blank" rel="noopener" href="https://www.yuque.com/sansongs/blog/sadgvq">https://www.yuque.com/sansongs/blog/sadgvq</a>），可以理解为使用最广泛的排序算法。</p>
<p>快速排序具有众多的优点，例如：「复杂度优异」、「原地排序」等</p>
<h3 id="2-实现-amp-讲解"><a href="#2-实现-amp-讲解" class="headerlink" title="2. 实现&amp;讲解"></a>2. 实现&amp;讲解</h3><p>学习快速排序，我们需要以分治思想的步骤拆分后进行考虑：</p>
<ul>
<li>Divide =&gt; 将整体 list，拆分为三部分，[0, pivot), pivot 和 (pivot, list.length)</li>
<li>Conquer =&gt; 无</li>
<li>Combine =&gt; 无</li>
</ul>
<p>比较重要的一步就是 partition，这一步做的事情可以理解为：拆分数组为 [lo … i)、a[i]、a(i, hi] 三部分<br>保证：list[lo … i) &lt;= a[i] &lt;= a(i, hi]</p>
<p>具体实现为：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 切分数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 过程：</span></span><br><span class="line"><span class="comment"> *    将数组切分成 a[lo .. i-1], a[i], a[i+1 .. hi], 同时保证：</span></span><br><span class="line"><span class="comment"> *      a[lo ... i-1] &lt;= pivot</span></span><br><span class="line"><span class="comment"> *      a[i+1 ... hi] &gt;= pivot</span></span><br><span class="line"><span class="comment"> *    此时交换 a[lo] 和 a[i] 的位置，即：</span></span><br><span class="line"><span class="comment"> *      确定 pivot 这个点位于其最终的位置上，并且保证了左边都小于基准，右边都大于基准</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>a   待排序的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>lo  起始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>hi  结束位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> partition = (a: <span class="built_in">number</span>[], <span class="attr">lo</span>: <span class="built_in">number</span>, <span class="attr">hi</span>: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = lo,</span><br><span class="line">    j = hi + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 基准值</span></span><br><span class="line">  <span class="keyword">const</span> pivot = a[lo]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 扫描左右，检查是否结束</span></span><br><span class="line">    <span class="keyword">while</span> (a[++i] &lt; pivot) <span class="keyword">if</span> (i === hi) <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">while</span> (a[--j] &gt; pivot) <span class="keyword">if</span> (j === lo) <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换元素</span></span><br><span class="line">    swap(a, i, j)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最终还需要交换一次标志和 i 的位置，保证 [lo, i]</span></span><br><span class="line">  swap(a, lo, j)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终 return 出来的值，是 pivot 处于最终的数组的位置索引，在经历了第一次 partition 后，我们的数组分为了三部分：</p>
<ul>
<li>pivot: 第一次 partition 中 pivot 的位置</li>
<li>[0, pivot): 这个区间内的值均比 pivot 小</li>
<li>(pivot, list.length - 1]: 这个区间内的值均比 pivot 大</li>
</ul>
<p>而后其实，就只是是递归的去处理[0, pivot) 和 (pivot, list.length - 1] 这两个区间即可：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 携带多个参数的快排内部方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>a   待排序的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>lo  起始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>hi  结束位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> _sort = (a: <span class="built_in">number</span>[], <span class="attr">lo</span>: <span class="built_in">number</span>, <span class="attr">hi</span>: <span class="built_in">number</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 递归终止条件</span></span><br><span class="line">  <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// pivotPos 为该元素最终的位置</span></span><br><span class="line">  <span class="comment">// 依据这个标志位，可以将数组拆分为 [lo, pivotPos), (pivotPos, hi] 两部分，再递归的去排即可</span></span><br><span class="line">  <span class="keyword">const</span> pivotPos = partition(a, lo, hi)</span><br><span class="line">  _sort(a, lo, pivotPos - <span class="number">1</span>)</span><br><span class="line">  _sort(a, pivotPos + <span class="number">1</span>, hi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-三路快排"><a href="#3-三路快排" class="headerlink" title="3. 三路快排"></a>3. 三路快排</h3><p>对于包含很多重复数字的输入而言，每一趟只能确定一个位置的 partition，显然不是最省时省力的方式。<br>我们可以设计三个指针，来帮助我们每次确定一组相同索引串，也就是下面实现的“三路快排”：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 三路快排实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 针对于重复元素很多的序列，三路快排可以将 O(n·lgn) 缩短至线性级别</span></span><br><span class="line"><span class="comment"> *  =&gt; 只是近似线性，还是比较看输入的特殊性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; shuffle, swap &#125; <span class="keyword">from</span> <span class="string">&#x27;../../../utils/lang/Array&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> quickIn3Way = (a: <span class="built_in">number</span>[]): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">  shuffle(a)</span><br><span class="line">  _quickIn3Way(a, <span class="number">0</span>, a.length - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> quickIn3Way</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 三路快排的具体的实现方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">a</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">lo</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">hi</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> _quickIn3Way = <span class="function">(<span class="params">a: <span class="built_in">number</span>[], lo: <span class="built_in">number</span>, hi: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">let</span> lt = lo,</span><br><span class="line">    gt = hi,</span><br><span class="line">    i = lo + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 标志位</span></span><br><span class="line">  <span class="keyword">const</span> pivot = a[lo]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保证 a[lo ... lt - 1] &lt; pivot, a[lt ... gt] = pivot, a[gt+1 ... hi] &gt; pivot</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= gt) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] === pivot) i++</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &gt; pivot) swap(a, i, gt--)</span><br><span class="line">    <span class="keyword">else</span> swap(a, i++, lt++)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _quickIn3Way(a, lo, lt - <span class="number">1</span>)</span><br><span class="line">  _quickIn3Way(a, gt + <span class="number">1</span>, hi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-排除输入的影响"><a href="#4-排除输入的影响" class="headerlink" title="4. 排除输入的影响"></a>4. 排除输入的影响</h3><p>我们可以注意到的就是，三路快排中，我们调用了一个 shuffle 的方法，这个方法的主要作用，就是打乱输入的顺序，尽可能减少最坏情况的发生。关于何时最坏，我们下一小节中会有所阐述，这里只给出相应的打乱算法：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 乱序输入</span></span><br><span class="line"><span class="comment"> * Rearranges the elements of the specified array in uniformly random order.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>a a the array to shuffle</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws </span>ArgumentsCheckError, if a is null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StdRandom</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> shuffle(a: <span class="built_in">number</span>[]): <span class="built_in">void</span> &#123;</span><br><span class="line">    StdRandom.validateNotNull(a)</span><br><span class="line">    <span class="keyword">const</span> len = a.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> r = i + <span class="built_in">this</span>.uniform(len - i)</span><br><span class="line">      <span class="keyword">const</span> tmp = a[i]</span><br><span class="line">      a[i] = a[r]</span><br><span class="line">      a[r] = tmp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-最坏-amp-平均"><a href="#5-最坏-amp-平均" class="headerlink" title="5. 最坏&amp;平均"></a>5. 最坏&amp;平均</h3><p>讨论一种算法，免不了讨论它的两种情况：最坏和平均</p>
<p>快速排序的最好情况，是每次都可以将输入对半分开，此时可以知道的就是：<br>T(n) = 2 * T(n/2) + N<br>此时就是一个严格的 n*logn 的总体复杂度 =&gt; 每次消减一半<br>平均情况与之类似，也为 O(n·logn)</p>
<p>快速排序的最坏情况，是每次确定的位置都在 0 位置或者 length - 1 位置上，此时没有非但没能做到拆分成两个规模差不多的子数组，还执行了一次复杂度为 n 的遍历操作。<br>T(n) = T(n - 1) + n<br>最终的结果就是 n 的复杂度</p>
<h3 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h3><p>一些过程中的工具方法和类型定义：</p>
<p>swap 方法：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交换数组元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>a     source array.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>pos1  fir positon</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>pos2  sec position</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throw </span>ArgumentsCheckError, if (a is null OR pos1 or pos2 out of range)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> swap = <span class="xml"><span class="tag">&lt;<span class="name">T</span> = <span class="string">number</span>&gt;</span>(a: T[], pos1: number, pos2: number): void =&gt; &#123;</span></span><br><span class="line"><span class="xml">  const l = a.length</span></span><br><span class="line"><span class="xml">  if (pos1 &lt; 0 || pos2 &lt; 0 || pos1 &gt;= l || pos2 &gt;= l)</span></span><br><span class="line"><span class="xml">    throw new ArgumentsCheckError(</span></span><br><span class="line"><span class="xml">      `pos1: $&#123;pos1&#125; or pos2: $&#123;pos2&#125; out of range.`</span></span><br><span class="line"><span class="xml">    )</span></span><br><span class="line"></span><br><span class="line"><span class="xml">  const tmp = a[pos1]</span></span><br><span class="line"><span class="xml">  a[pos1] = a[pos2]</span></span><br><span class="line"><span class="xml">  a[pos2] = tmp</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>测试用例:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> quickSort <span class="keyword">from</span> <span class="string">&#x27;../Quick&#x27;</span></span><br><span class="line"><span class="keyword">import</span> quickIn3Way <span class="keyword">from</span> <span class="string">&#x27;../Quick/3ways&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; casesGenerator &#125; <span class="keyword">from</span> <span class="string">&#x27;../../../utils/generator/cases/sort.generator&#x27;</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;Quick Sort Tests.&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  test(<span class="string">&#x27;common quick sort should run correctly.&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> cases: TSortCases[] = casesGenerator()</span><br><span class="line">    cases.forEach(<span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; input, output &#125; = c</span><br><span class="line">      <span class="keyword">const</span> _input = input()</span><br><span class="line">      quickSort(_input)</span><br><span class="line">      expect(_input).toEqual(output)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  test(<span class="string">&#x27;quick sort in 3 ways should run correctly.&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> cases: TSortCases[] = casesGenerator()</span><br><span class="line">    cases.forEach(<span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; input, output &#125; = c</span><br><span class="line">      <span class="keyword">const</span> _input = input()</span><br><span class="line">      quickIn3Way(_input)</span><br><span class="line">      expect(_input).toEqual(output)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>测试用例的 generator：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 带重复元素的数组</span></span><br><span class="line"><span class="keyword">const</span> unsortedArrCreator = (): <span class="function"><span class="params">TSortCases</span> =&gt;</span></span><br><span class="line">  simpleCasesCreator(genUnsortedFilledArr())</span><br><span class="line"><span class="comment">// 不带重复元素的数组</span></span><br><span class="line"><span class="keyword">const</span> unsortedUnDuplicateArrCreator = (): <span class="function"><span class="params">TSortCases</span> =&gt;</span></span><br><span class="line">  simpleCasesCreator(genUnduplicateUnsortedArray())</span><br><span class="line"><span class="comment">// 空数组</span></span><br><span class="line"><span class="keyword">const</span> emptyArrCreator = (): <span class="function"><span class="params">TSortCases</span> =&gt;</span> simpleCasesCreator([])</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sort 相关的 case 的 generator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> casesGenerator = (): TSortCases[] =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> cases: TSortCases[] = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 无序数组，带有重复元素</span></span><br><span class="line">  <span class="keyword">while</span> (count++ &lt; <span class="number">10</span>) cases.push(unsortedArrCreator())</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 无序数组，不带重复元素</span></span><br><span class="line">  <span class="keyword">while</span> (count++ &lt; <span class="number">20</span>) cases.push(unsortedUnDuplicateArrCreator())</span><br><span class="line"></span><br><span class="line">  cases.push(emptyArrCreator())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cases</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异常：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _argumentCheckMsg = <span class="string">&#x27;argument check error.&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ArgumentsCheckError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">msg: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="string">`[ArgumentsCheckError]: <span class="subst">$&#123;msg || _argumentCheckMsg&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tags"><a href="/tags/algorithm/"><i class="fa fa-tag"></i>algorithm</a><a href="/tags/sort/"><i class="fa fa-tag"></i>sort</a></div><div class="post-nav"><a class="next" href="/2021/01/12/dataStructure/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/">优先队列</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 15px;">杂谈</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/HTTP-%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/" style="font-size: 15px;">HTTP 权威指南</a> <a href="/tags/%E3%80%8A%E4%B8%8D%E5%9C%A8%E4%BB%96%E6%96%B9%E3%80%8B/" style="font-size: 15px;">《不在他方》</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/You-Don-t-Know-Javascript/" style="font-size: 15px;">You Don't Know Javascript</a> <a href="/tags/%E3%80%8A%E5%A4%A9%E6%89%8D%E5%9C%A8%E5%B7%A6-%E7%96%AF%E5%AD%90%E5%9C%A8%E5%8F%B3%E3%80%8B/" style="font-size: 15px;">《天才在左 疯子在右》</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 15px;">数据结构</a> <a href="/tags/%E5%9F%BA%E6%9C%AC%E5%8A%9F/" style="font-size: 15px;">基本功</a> <a href="/tags/parser/" style="font-size: 15px;">parser</a> <a href="/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">源码学习</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/Acorn-js/" style="font-size: 15px;">Acorn.js</a> <a href="/tags/Babel/" style="font-size: 15px;">Babel</a> <a href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" style="font-size: 15px;">工程化</a> <a href="/tags/leetcode/" style="font-size: 15px;">leetcode</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/rfc/" style="font-size: 15px;">rfc</a> <a href="/tags/uri/" style="font-size: 15px;">uri</a> <a href="/tags/%E7%BC%96%E8%AF%91/" style="font-size: 15px;">编译</a> <a href="/tags/%E4%B8%A4%E5%91%A8%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">两周自制脚本语言</a> <a href="/tags/jquery/" style="font-size: 15px;">jquery</a> <a href="/tags/%E6%8A%80%E6%9C%AF%E9%92%BB%E7%A0%94/" style="font-size: 15px;">技术钻研</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 15px;">读书笔记</a> <a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">基础</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/" style="font-size: 15px;">前端进阶</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E5%9B%BD%E9%99%85%E5%8C%96/" style="font-size: 15px;">前端国际化</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">网络</a> <a href="/tags/typescript/" style="font-size: 15px;">typescript</a> <a href="/tags/Array-%E6%96%B9%E6%B3%95/" style="font-size: 15px;">Array 方法</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">前端基础</a> <a href="/tags/virtual-dom/" style="font-size: 15px;">virtual dom</a> <a href="/tags/%E9%98%9F%E5%88%97/" style="font-size: 15px;">队列</a> <a href="/tags/%E6%95%B0%E7%BB%84/" style="font-size: 15px;">数组</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="/tags/sort/" style="font-size: 15px;">sort</a></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">叁歌.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"></div></body></html>